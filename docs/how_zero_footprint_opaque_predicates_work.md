## What Is Zero Footprint Opaque Predicates Work And How It Works

For a detailed explanation, check out our [paper](https://rdcu.be/cpnNf). But if you just want a simplified explanation, this document is for you! 

It's called Zero Footprint Opaque Predicates because the opaque predicates it constructs resemble every other predicates typically found in an unobfuscated binary. 

Why do we want opaque predicates to resemble real predicates? Because once an opaque predicate is detected, deobfuscation is as simple as changing the conditional branch instruction to a non-conditional branch instruction. For opaque predicates' effects to last, they need to be stealthy. And one way to be stealthy is to resemble real predicates _syntactically_ and _semantically_. 

To resemble real predicates syntactically means that it "looks" like real predicates from the disassembly. Whereas to resemble real predicates semantically means that it "behaves" like real predicates at program runtime. 

To syntactically resemble real predicates, the problem is two-folds. Firstly, our opaque predicates use naturally occurring invariants. An invariant is just a specific program behavior (e.g., `x > 10`) that is always true at a particular line of code, and every opaque predicate requires one invariant in order to disguise itself as a conditional branch instruction. Naturally occurring invariants are just invariants that already exist in the original program. We want to make this distinctive because other approaches to constructing opaque predicates inject their own code to create the invariants (i.e., synthetic invariants) for their opaque predicates. And because they use synthetic invariants that are constructed in similar manners, every opaque predicate they insert have distinguish features that they all share and can stand out from the other real predicates. Using naturally occurring invariants ensure natural diversity among our opaque predicates' invariants. Secondly, once we have the invariants, we still need to construct the opaque predicates from them. To ensure the eventual opaque predicates syntactically resemble real predicates, we first did a study to identify syntactic features that represent real predicates. We then use the godly tool [Rosette](https://emina.github.io/rosette/) to construct our opaque predicates such that the resulting opaque predicates share the syntactic features we identified. 

To semantically resemble real predicates, we use value sets as our invariants. A value set contains all possible values that can be assigned to a variable at a particular line of code. And we can make sure that the value sets we use DO contain all possible values by using this cool analysis technique called [abstract interpretation](https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html). To use a value set as an invariant, the corresponding opaque predicate have to evaluate each value in the value set to the same truth value. Thankfully, the godly tool Rosette can also do that for us.
