## What Is Zero Footprint Opaque Predicates?

For a detailed explanation, check out our [paper](https://rdcu.be/cpnNf). But if you just want a simplified explanation, this page is for you! 

It's called Zero Footprint Opaque Predicates because the opaque predicates it constructs resemble every other predicates typically found in an unobfuscated binary. 

Why do we want opaque predicates to resemble real predicates? Because once an opaque predicate is detected, deobfuscation is as simple as changing the conditional branch instruction to a non-conditional branch instruction. For opaque predicates' effects to last, they need to be stealthy against manual and automated analysis. To be stealthy against manual analysis (e.g., heuristic attacks, pattern matching attacks), the opaque predicates need to resemble real predicates _syntactically_. To be stealthy against automated analysis, the opaque predicates need to resemble real predicates _semantically_.

Resembling real predicates syntactically means that it "looks" like real predicates from the disassembly. Whereas resembling real predicates semantically means that it "behaves" like real predicates at program runtime. 

To syntactically resemble real predicates, the problem is two-folds. 

Firstly, the construction of the invariants cannot syntactically stand out. To ensure this, our opaque predicates use naturally occurring invariants. An invariant is just a specific program behavior (e.g., `x > 10`) that is always true at a particular line of code, and every opaque predicate requires one invariant in order to disguise itself as a conditional branch instruction. Naturally occurring invariants are just invariants that already exist in the original program. We want to make this distinctive because other approaches to constructing opaque predicates inject their own code to create the invariants (i.e., synthetic invariants) for their opaque predicates. And because they use synthetic invariants that are constructed in similar manners, every opaque predicate they insert have distinctive features that they all share and thus can stand out from the other real predicates. Naturally occurring invariants create natural diversity among our opaque predicates' invariants since they may not all be constructed in similar manners. 

Secondly, the construction of the opaque predicates using the invariants cannot syntactically stand out as well. To ensure this, we first did a study to identify syntactic features that represent real predicates. We then use the godly tool [Rosette](https://emina.github.io/rosette/) to construct our opaque predicates such that the resulting opaque predicates share the syntactic features we identified. 

To semantically resemble real predicates, we use value sets as our invariants so our opaque predicates may take on different values at program runtime. A value set contains all possible values that can be assigned to a variable at a particular line of code. And we can make sure that the value sets we use DO contain all possible values by using this cool analysis technique called [abstract interpretation](https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html) (for this project we use [Frama-C's implementation](https://frama-c.com/fc-plugins/eva.html)). To use a value set as an invariant, the corresponding opaque predicate has to evaluate each value in the value set to the same truth value (T/F). Thankfully, the godly tool Rosette can also do that for us.
